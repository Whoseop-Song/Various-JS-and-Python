// Generated by CoffeeScript 1.12.5
(function() {
  var Environment, Force, Momentum, P, RigObject, Utils, Vector, Velocity, base, base1, base2, exports, info, point,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  info = document.getElementById("info");

  (base = Array.prototype).sum || (base.sum = function() {
    return this.reduce(function(a, b) {
      return a + b;
    });
  });

  (base1 = Number.prototype).roundTo || (base1.roundTo = function(decNum) {
    var mult;
    if (decNum == null) {
      decNum = 0;
    }
    mult = Math.pow(10, decNum);
    return Math.round(this.valueOf() * mult) / mult;
  });

  (base2 = Array.prototype).mapKeys || (base2.mapKeys = function(prop) {
    return this.map(function(el) {
      return el[prop];
    });
  });

  Utils = (function() {
    function Utils() {}

    Utils.distance = function(from, to) {
      return Math.sqrt(Math.pow(from.x - to.x, 2) + Math.pow(from.y - to.y, 2));
    };

    Utils.getAngle = function(x, y) {
      return this.mod(Math.atan2(y, x), this.TWOPI);
    };

    Utils.degToRad = function(deg) {
      return deg * (Math.PI / 180);
    };

    Utils.radToDeg = function(rad) {
      return rad * (180 / Math.PI);
    };

    Utils.mod = function(a, b) {
      return a % b + (a < 0 ? b : 0);
    };

    Utils.TWOPI = Math.PI * 2;

    return Utils;

  })();

  P = (function() {
    function P(x1, y1) {
      this.x = x1 != null ? x1 : 0;
      this.y = y1 != null ? y1 : 0;
    }

    P.prototype.distance = function(toPoint) {
      return Utils.distance(this, toPoint);
    };

    P.prototype.moveByDelta = function(dPos, dt) {
      this.setX(this.x + dPos.x * dt);
      return this.setY(this.y + dPos.y * dt);
    };

    P.prototype.setX = function(x1) {
      this.x = x1 != null ? x1 : this.x;
      if (Math.abs(this.x) < 0.0000001) {
        return this.x = 0;
      }
    };

    P.prototype.setY = function(y1) {
      this.y = y1 != null ? y1 : this.y;
      if (Math.abs(this.y) < 0.0000001) {
        return this.y = 0;
      }
    };

    P.prototype.toString = function() {
      return "(" + this.x + ", " + this.y + ")";
    };

    return P;

  })();

  point = function(x, y) {
    return new Point(x, y);
  };

  Vector = (function(superClass) {
    extend(Vector, superClass);

    Vector.sum = function(vectors) {
      if ((vectors != null ? vectors.length : void 0) > 0) {
        return vectors.reduce(function(prev, next) {
          return prev.plus(next);
        });
      } else {
        return new this();
      }
    };

    function Vector() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      Vector.__super__.constructor.apply(this, args);
    }

    Vector.prototype.getAngle = function() {
      return Utils.getAngle(this.x, this.y);
    };

    Vector.prototype.getAmount = function() {
      return Utils.distance(new P(0, 0), this);
    };

    Vector.prototype.setAmount = function(amount) {
      var angle;
      if (Math.abs(this.x) > 0 || Math.abs(this.y) > 0) {
        angle = this.getAngle();
        this.setX(Math.cos(angle) * amount);
        this.setY(Math.sin(angle) * amount);
      }
      return this;
    };

    Vector.prototype.plus = function(otherVector) {
      return new this.constructor(this.x + otherVector.x, this.y + otherVector.y);
    };

    Vector.prototype.toString = function() {
      return this.constructor.name + " is " + (this.getAmount()) + " (" + this.constructor.unit + ") pointing @ " + (Utils.radToDeg(this.getAngle())) + " deg.";
    };

    Vector.prototype.oposite = function(amount) {
      return new Vector(-this.x, -this.y).setAmount(amount);
    };

    Vector.prototype.clone = function() {
      return new Vector(this.x, this.y);
    };

    return Vector;

  })(P);

  Velocity = (function(superClass) {
    extend(Velocity, superClass);

    function Velocity() {
      return Velocity.__super__.constructor.apply(this, arguments);
    }

    Velocity.unit = "px/ms";

    Velocity.prototype.accelerate = function(force, mass, dt) {
      var accel;
      accel = force.clone();
      accel.setAmount(force.getAmount() / mass);
      return this.moveByDelta(accel, dt);
    };

    return Velocity;

  })(Vector);

  Force = (function(superClass) {
    extend(Force, superClass);

    function Force() {
      return Force.__super__.constructor.apply(this, arguments);
    }

    Force.unit = "N";

    return Force;

  })(Vector);

  Environment = (function() {
    function Environment() {
      this.gravity = new Force();
      this.airResist = 0;
      this.friction = 0;
      this.objects = [];
    }

    Environment.prototype.addObject = function(obj, controllable) {
      if (controllable == null) {
        controllable = false;
      }
      obj.env = this;
      this.objects.push(obj);
      if (controllable) {
        return this.controllable = obj;
      }
    };

    Environment.prototype.nextTick = function(dt) {
      return this.objects.map(function(o) {
        return o.nextTick(dt);
      });
    };

    return Environment;

  })();

  Momentum = (function(superClass) {
    extend(Momentum, superClass);

    Momentum.unit = "(kg*px)/ms";

    function Momentum(mass, velocity) {
      Momentum.__super__.constructor.call(this, velocity.x, velocity.y);
      this.setAmount(mass * velocity.getAmount());
    }

    return Momentum;

  })(Vector);

  RigObject = (function() {
    function RigObject(pos, mass1, velocity1) {
      this.pos = pos;
      this.mass = mass1;
      this.velocity = velocity1;
      this.velocity || (this.velocity = new Velocity());
      this.forces = [];
    }

    RigObject.prototype.netForce = function() {
      var airResist, applied, force, friction, netForce;
      applied = Force.sum(this.forces);
      this.forces = [];
      force = applied.plus(this.env.gravity);
      airResist = this.velocity.oposite(this.env.airResist);
      friction = this.velocity.oposite(this.env.friction);
      netForce = Force.sum([force, airResist, friction]);
      return netForce;
    };

    RigObject.prototype.nextTick = function(dt) {
      var netForce;
      if (this.friction > this.velocity.amount) {
        this.velocity.setAmount(0);
      }
      netForce = this.netForce();
      this.velocity.accelerate(netForce, this.mass, dt);
      this.pos.moveByDelta(this.velocity, dt);
      return info.innerHTML = this.velocity + "<br/>" + netForce + "<br/>" + this.getMomentum() + "<br/>" + this.pos;
    };

    RigObject.prototype.getMomentum = function() {
      return new Momentum(this.mass, this.velocity);
    };

    RigObject.prototype.kick = function(up, down, left, right) {
      if (up == null) {
        up = 0;
      }
      if (down == null) {
        down = 0;
      }
      if (left == null) {
        left = 0;
      }
      if (right == null) {
        right = 0;
      }
      if (up) {
        this.forces.push(new Force(0, -up));
      }
      if (down) {
        this.forces.push(new Force(0, down));
      }
      if (left) {
        this.forces.push(new Force(-left, 0));
      }
      if (right) {
        return this.forces.push(new Force(right, 0));
      }
    };

    return RigObject;

  })();

  if (!exports) {
    exports = window;
  }

  exports.P = P;

  exports.Vector = Vector;

  exports.Force = Force;

  exports.RigObject = RigObject;

  exports.Environment = Environment;

  exports.Velocity = Velocity;

}).call(this);
